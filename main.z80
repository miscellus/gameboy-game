ASSERTIONS EQU 0

;-------------
; gb-template - bank0.asm
;-------------
; Includes
;-------------
	
INCLUDE "macros.z80"
INCLUDE "hardware.z80"
INCLUDE "header.z80"
INCLUDE "tiles.z80"
INCLUDE "map.z80"
INCLUDE "memory.z80"
INCLUDE "variables.z80"

;-------------
; Start
;-------------
SECTION "DMA Routine",ROM0
DMACode:
	DB  $F5, $3E, $C1, $EA, $46, $FF, $3E, $28, $3D, $20, $FD, $F1, $D9
DMACodeEnd:

SECTION "Program Start",ROM0[$150]
ProgramStart:
	ei				 ;enable interrupts
	ld  sp,$FFFE  ; Init stack pointer
	ld  a,IEF_VBLANK ;enable vblank interrupt
	ld  [rIE],a

	xor a
	ldh [rLCDC],a 	 ;LCD off
	ldh [rSTAT],a

; 	ld  a,%00011011  ;shade palette (11 10 01 00)
	ld  a,%11100100  ;shade palette (11 10 01 00)
	ldh [rBGP],a 	 ;setup palettes
	ldh [rOCPD],a
	ldh [rOBP0],a

	call LoadTiles
	call LoadMap
	call ClearSprites
; 	call ClearScreen


F = (LCDCF_ON|LCDCF_WIN9C00|LCDCF_BG8000|LCDCF_OBJON|LCDCF_BGON)
	ld  a,F  ;turn on LCD, BG0, OBJ0, etc
	ldh [rLCDC],a    ;load LCD flags

	rst CopyDmaResetVector

InitRam:
	xor a
	ld [ButtonsDown],a
	ld [ButtonsPressed],a
	ld [PlayerNumFramesInAir], a
	ld [DeltaX], a
	ld [DeltaY], a

	ld a, 160/2
	ld [SprPlayer.X], a
	ld a, 144/2
	ld [SprPlayer.Y], a

	ld a, 80
	ld [PlayerX], a
	ld a, 64
	ld [PlayerY], a
	ld a, $1e
	ld [SprPlayer.Tile], a
	ld a, $8A
	ld [SprPlayer.Flags], a

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GameLoop:
; The outline of the main game loop is as follows:
;     1) Wait for a vblank to have occured
;     2) Read and store the state of the buttons on the gameboy
;     3) Update the player's position (handling collisions)
;     4) Doing the DMA transfer to the pixel processing unit (PPU)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.WaitForVBlank:
	halt ; @HardwareBug:
	nop ; If interrupts are disabled, HALT jumps one instruction!

	ld a, [IsWaitingForVBlank]
	or a
	jr nz, .WaitForVBlank ; zero means vblank has happened

	; Here a should be zero, so increment to 1 to signify wait for vblank
	inc a
	ld [IsWaitingForVBlank], a

	ld a, [VBlankCount]
	inc a
	ld [VBlankCount], a
	
;;;;;;;;;;;;;;;;;;;
UpdateInput:
;
; NOTE(jakob):
; a bit value of 0 means button is down
;
;;;;;;;;;;;;;;;;;;;
	ld  a,JoyPad_Select_DPad
	ldh  [JoyPad],a
	ldh  a,[JoyPad]    ;takes a few cycles to get accurate reading
	ldh  a,[JoyPad]
	ldh  a,[JoyPad]
	ldh  a,[JoyPad]
;	cpl ;complement a
	or %11110000	;mask dpad buttons
	swap a
	ld  b,a ; Save D-Pad states in register b

	ld  a,JoyPad_Select_Other
	ldh  [JoyPad],a  
	ldh  a,[JoyPad]
	ldh  a,[JoyPad]
	ldh  a,[JoyPad]
	ldh  a,[JoyPad]
;	cpl
	or %11110000 ; mask other buttons
	and  b


	ld  c,a ; b <- New Down state

	ld  a,[ButtonsDown]
	cpl
	or c
	ld  [ButtonsPressed],a
	ld  a, c
	ld  [ButtonsDown],a

	ld  a, JoyPad_Select_Other|JoyPad_Select_DPad
	ld  [JoyPad], a


	;;; Intended fall through ;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
UpdatePlayerPosition:
; Assert c contains ButtonsPressed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

HSpeed equ 3
JumpForce equ 28

ButtonHandle: MACRO
	bit \1, c
	jr nz, .skip\@
	\2
.skip\@:
ENDM

	xor a
	ButtonHandle ButtonRight, add a\, HSpeed
	ButtonHandle ButtonLeft, sub a\, HSpeed
	ld e, a
	
	ld a, [DeltaX]
	add a, e
	; n = n - ((n + (n>0 ? 7 : 0))>>3)
	ld l, a
	bit 7, a
	jr nz, .NonPositiveDeltaX
	or a
	jr z, .NonPositiveDeltaX
	; a > 0
	add a, 15
.NonPositiveDeltaX:
	sra a
	sra a
	sra a
	sra a
	ld d, a
	ld a, l
	sub a, d

	ld [DeltaX], a
	sra a
	sra a
	sra a
	ld e, a

	; Add delta X
	ld a, [PlayerX]
	add a, e
	ld [PlayerX], a

	ld b, a

	ld l, a
	ld a, [PlayerY]
	call IsOccupiedBySolid;(l,a)

	jr z, .NoCollisionX
	; A collision happend on the x axis
	ld a, b            ; Restore new x coordinate
	bit 7, e
	jr z, .GoingRight
	sub a, e           ; If deltaX was negative, subtract it to snap to the left
.GoingRight:
	and a, %11111000   ; mask off the offset to snap into grid-alignment
	ld [PlayerX], a
	ld b, a

	xor a
	ld [DeltaX], a
.NoCollisionX:

	ld a, [ButtonsPressed]
	ld c, a
	xor a
	bit ButtonUp, c
	jr nz, .NoJump
	ld e, a
	; Check if on ground
	ld a, [PlayerX]
	ld c, a
	ld l, a
	ld a, [PlayerY]
	add a, 8
	call GetTileAddress
	ld a, c
	and a, %111
	ld a, [hl+]
	jr z, .TestGrounded
	ld c, a
	ld a, [hl]
	or a, c
.TestGrounded:
	or a
	ld a, e
	jp z, .NoJump
	sub a, JumpForce
	ld [DeltaY], a
.NoJump:
	
	;ButtonHandle ButtonDown, add a\, Speed


	ld e, a
	inc e
	inc e
	inc e

	ld a, [DeltaY]
	add a, e
	; n = n - ((n + (n>0 ? 7 : 0))>>3)
	ld l, a
	bit 7, a
	jr nz, .NonPositiveDeltaY
	or a
	jr z, .NonPositiveDeltaY
	; a > 0
	add a, 15
.NonPositiveDeltaY:
	sra a
	sra a
	sra a
	sra a
	ld d, a
	ld a, l
	sub a, d

	ld [DeltaY], a
	sra a
	sra a
	sra a
	ld e, a

	; Add delta Y
	ld a, [PlayerY]
	add a, e
	ld [PlayerY], a
	
	ld l, b ; Current X coordinate
	ld b, a ; Candidate Y corrdinate
	call IsOccupiedBySolid;(l,a)

	jr z, .NoCollisionY
	; A collision happend on the y axis
	ld a, b            ; Restore new y coordinate
	bit 7, e
	jr z, .GoingUp
	sub a, e           ; If deltaY was negative, subtract it to snap upwards
.GoingUp:
	and a, %11111000   ; mask off the offset to snap into grid-alignment
	ld [PlayerY], a
	ld b, a

	xor a
	ld [DeltaY], a
.NoCollisionY:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
UpdateViewPort:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ld a, [PlayerX]
	sub a, 160/2 - 8
	ld [rScreenX], a

	ld a, [PlayerY]
	sub a, 144/2 - 16
	ld [rScreenY], a

	call DMA ;call DMA routine in HRAM
	jp GameLoop

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ClearSprites:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ld  hl, Sprites
	xor a
	ld  c, 4*40
	call MemFill255
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ClearScreen:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ld  hl, _SCRN0    ;load map0 ram
	xor a
	ld  bc, 1024
	call MemFill
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadTiles:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ld  hl, TileData
	ld  de, _VRAM
	ld  bc, (TileDataEnd-TileData)
	call MemCopy
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadMap:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ld  hl, MapData  ;same as LoadTiles
	ld  de, _SCRN0
	ld  bc, (MapDataEnd-MapData)
	call MemCopy
	ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IsOccupiedBySolid:
; Takes: A as the Y coordinate
; Takes: L as the X corrdinate
; Returns: If occupied in the zero flag (ZF=1 means occupied)
; Clobbers: A, D, H, L, F
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	rlca
	rlca
	ld h, a
	rlca
	and a, %00111000; These are the offset bits for Y
	ld d, a

	ld a, l
	and a, %00000111; These are the offset bits for X
	or a, d
	ld d, a
	ld a, l
	rrca
	rrca
	rrca
	and a, %00011111
	ld l, a

	ld a, h
	and a, %11100000
	add a, l
	;add a, (MapData&$ff)
	ld l, a

	ld a, h
	and a, %00000011
	add a, (MapData>>8)
	ld h, a

	; Always look at (x+0,y+0)
	ld a, [hl+]
	or a
	ret nz

	ld a, d
	and a, %00000111
	jr z, .SkipUnalignedXCheck
	; If not grid aligned on the x axis, check also (x+1,y+0) 
	ld a, [hl]
	or a
	ret nz
.SkipUnalignedXCheck:
	ld a, d
	and a, %00111000
	ret z
	
	; Go relative to (-1, +1)
	; 8 cycles, 8 bytes (This is faster than doing 16 bit add)
	ld a, 31
	add a, l
	ld l, a
	ld a, 0
	adc a, h
	ld h, a

	; If not grid aligned on the y axis, check also (x+0,y+1) 
	ld a, [hl+]
	or a
	ret nz

	ld a, d
	and a, %00000111
	ret z
	; If neither grid aligned on x nor y, check (x+1,y+1)
	ld a, [hl]
	or a
	ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GetTileAddress:
	; Takes: A as the Y coordinate
	; Takes: L as the X corrdinate
	; Returns address of underlying tile in HL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	rlca
	rlca
	ld h, a
	
	ld a, l
	rrca
	rrca
	rrca
	and a, %00011111
	ld l, a

	ld a, h
	and a, %11100000
	add a, l
	;add a, (MapData&$ff)
	ld l, a

	ld a, h
	;and a, %00011100 These are the offset bits
	and a, %00000011
	add a, (MapData>>8)
	ld h, a

	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GetTile_Old:
	; a = TileY
	; e = TileX
	; d = 0
	; result in a
	; Clobbers af, hl
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	push de

	ld hl, MapData
	add hl, de

	; DE <- A*32
	swap a
	rlca
	ld e, a
	and a, %00011111
	ld d, a
	ld a, e
	and a, %11100000
	ld e, a

	add hl, de

	ld a, [hl]
	pop de
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PositionToMapDataOffset:
	; (LeafCall)
	; Takes: an X,Y coordinate in registers E (for X) and A (for Y)
	; Takes: EXPLICIT return address in HL
	; Returns: the corresponding offset into a 32x32 tile map in DE
	; Clobbers: D
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	rlca
	rlca
	ld d, a
	
	ld a, e
	rrca
	rrca
	rrca
	and a, %00011111
	ld e, a

	ld a, d
	and a, %11100000
	add a, e
	ld e, a

	ld a, d
	;and a, %00011100 These are the offset bits
	and a, %00000011
	ld d, a
	; Note since leaf function, jump to explicit return address
	jp hl
PositionToMapDataOffsetEnd: